/*
«апрограммировать функции дл€ работы с приоритетной очередью. ќчередь запросов формируетс€ согласно
приоритету, сн€тие выполн€етс€ подр€д, начина€ с младших адресов ( то есть с начала очереди).
ќчередь должна представл€ть из себ€ массив, в котором должен выполн€тьс€ сдвиг после каждого чтени€
и сдвиг Ч после достижени€ границы пам€ти, котора€ выделена дл€ очереди. ѕриоритет: минимальное значение
числового параметра, при совпадении параметров Ч LIFO (Ќачина€ с хвоста очереди, если значение
очередного элемента в ней больше или равно вставл€емому - двигать вставл€емый к началу очереди.)
*/



#include <iostream>
#include <string>
#include "queue_priority.h"

using namespace std;

int main() {
	setlocale(LC_ALL, "Rus");

	try {
		//проверка
		QueueP<double> p;
		cout << "«аполнение очереди и вывод этой очереди" << endl;
		p.push(10.5);
		p.push(6.2);
		p.push(8.8);
		p.push(2.9);
		p.push(4.1);
		p.printQueueP();
		cout << "»звлекаем элемент из очереди: " << p.pop() << endl;
		cout << "¬ыводим обновленную очередь" << endl;
		p.printQueueP();
		cout << "ƒобавл€ем элемент в очередь и выводим очередь" << endl;
		p.push(199.5);
		p.printQueueP();

		//ещЄ одна проверка
		QueueP<char> me(4);
		me.push('c');
		me.push('b');
		me.push('a');
		me.push('d');
		me.printQueueP();
		me.pop();
		me.printQueueP();

	}
	catch(const char *x){
		cout << x << endl;
	}

	system("pause");
	return 0;
}